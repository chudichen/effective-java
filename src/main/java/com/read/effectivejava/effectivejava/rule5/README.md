# 第五条：避免创建不必要的对象

在Java1.5发行版本中，有一种创建多余对象的新方法，称为自动装箱（autoboxing），它允许程序员将基本类型与装箱类型（Boxed Primitive Type）混用，按需要自动装箱和拆箱。自动装箱使得基本类型和装箱类型之间的差别变得模糊起来，但是并没有完全消除。他们在语义上还有着微妙的差别，在性能上也有着比较明显的差别。考虑下面的程序，它计算所有int正值的总和。为此，程序必须使用long来计算，因为int不够大，无法容乃所有的int正值的总和。
详情见AutoBoxingTest
这段程序算出的答案是正确的，但是比实际情况要更慢一些，因为只打错了一个字符，变量sum被声明成了Long而不是long，意味着程序构造了大约有2^31个多余的Long实例（大约每次往Long sum中增加long时构造一个实例）。将Long改为long之后，性能大幅度提升。结论很明显：**要优先使用基本类型而不是装箱类型，要当心无意识的自动装箱**。
不要错误地认为本条目所介绍的内容暗示着“创建对象的代价非常昂贵，我们要尽可能地避免创建对象。”相反，由于小对象的构造只做很少量的显示工作，小对象的创建和回收动作是非常廉价的，特别是在现代JVM上更是如此。通过创建附加的对象，提升程序的清晰性，简洁性和功能性，这通常是件好事。
反之，通过维护自己的对象池来避免创建对象并不是一种很好的做法，除非池中的对象是非常重量级别的。真正正确使用对象池的典范就是数据库连接池。建立数据库连接的代价是非常昂贵的，因此重用这些对象是非常有意义的。而且数据库的许可可能限定你只能使用一定数量的连接。但是，一般而言，维护自己的对象池必定会把代码弄得很乱，同时增加内存占用（footprint），并且还会损害性能。现代JVM具有高度优化的垃圾收集器，其性能很容易超过轻量级对象池的性能。
与本条目对应的是第39条中有关“保护性拷贝（defensive copy）”的内容。本条目提及“当你重用现有对象的时候，请不要创建新的对象”，而39条则是说“当你创建新对象的时候，请不要重用现有对象”。注意，在提倡保护性拷贝的时候，因为重用对象而付出的代价要远远大于因为创建重复对象而付出的代价。必要时如果没能实施保护性拷贝，将会导致潜在的村务和安全漏洞。而不必要的创建对象则只会影响程序的风格和性能。